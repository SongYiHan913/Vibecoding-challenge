[
  {
    "id": "java-001",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "easy",
    "experienceLevel": "junior",
    "field": "java",
    "category": "java",
    "question": "Java에서 객체지향 프로그래밍의 4대 특징 중 하나가 아닌 것은?",
    "options": [
      "캡슐화",
      "상속",
      "다형성",
      "재귀"
    ],
    "correctAnswer": 3,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 5,
    "tags": [
      "객체지향",
      "기초"
    ]
  },
  {
    "id": "java-002",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "easy",
    "experienceLevel": "junior",
    "field": "java",
    "category": "java",
    "question": "Java에서 제네릭(Generic)의 주요 목적은 무엇인가요?",
    "options": [
      "코드 압축",
      "성능 향상",
      "타입 안정성 보장",
      "디버깅 간소화"
    ],
    "correctAnswer": 2,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 5,
    "tags": [
      "제네릭",
      "타입안정성"
    ]
  },
  {
    "id": "java-003",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "medium",
    "experienceLevel": "junior",
    "field": "java",
    "category": "java",
    "question": "다음 중 Java Stream API를 사용할 때 중간 연산에 해당하는 것은?",
    "options": [
      "forEach()",
      "collect()",
      "filter()",
      "count()"
    ],
    "correctAnswer": 2,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 10,
    "tags": [
      "스트림",
      "중간연산"
    ]
  },
  {
    "id": "java-004",
    "type": "technical",
    "format": "essay",
    "difficulty": "medium",
    "experienceLevel": "junior",
    "field": "java",
    "category": "java",
    "question": "Spring Framework의 DI(의존성 주입)가 어떤 문제를 해결하고, 어떤 방식으로 주입되는지 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "DI는 객체 간의 강한 결합을 줄이고 테스트와 유지보수를 용이하게 합니다. 생성자 주입, 세터 주입, 필드 주입 방식이 있습니다.",
    "requiredKeywords": [
      "결합도",
      "생성자 주입",
      "세터 주입"
    ],
    "points": 15,
    "tags": [
      "DI",
      "Spring",
      "의존성"
    ]
  },
  {
    "id": "java-005",
    "type": "technical",
    "format": "essay",
    "difficulty": "hard",
    "experienceLevel": "junior",
    "field": "java",
    "category": "java",
    "question": "JPA에서 N+1 문제란 무엇이며, 이를 해결하기 위한 전략을 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "N+1 문제는 연관된 데이터를 지연 로딩할 때 쿼리가 반복 실행되는 현상입니다. fetch join 또는 EntityGraph를 통해 해결할 수 있습니다.",
    "requiredKeywords": [
      "N+1",
      "fetch join",
      "EntityGraph"
    ],
    "points": 20,
    "tags": [
      "JPA",
      "성능최적화"
    ]
  },
  {
    "id": "java-006",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "medium",
    "experienceLevel": "senior",
    "field": "java",
    "category": "java",
    "question": "Spring AOP에서 @Around 어노테이션의 역할은 무엇인가요?",
    "options": [
      "메서드 실행 전만 실행",
      "메서드 실행 후만 실행",
      "예외 발생 시만 실행",
      "메서드 실행 전후를 모두 제어"
    ],
    "correctAnswer": 3,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 10,
    "tags": [
      "Spring",
      "AOP",
      "어노테이션"
    ]
  },
  {
    "id": "java-007",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "medium",
    "experienceLevel": "senior",
    "field": "java",
    "category": "java",
    "question": "JPA에서 즉시 로딩(EAGER)이 아닌 지연 로딩(LAZY)을 사용하는 주된 이유는?",
    "options": [
      "쿼리 실행 속도를 높이기 위해",
      "객체를 미리 초기화하기 위해",
      "메모리 사용량을 줄이기 위해",
      "불필요한 조인을 피하고 성능을 최적화하기 위해"
    ],
    "correctAnswer": 3,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 10,
    "tags": [
      "JPA",
      "LAZY",
      "성능"
    ]
  },
  {
    "id": "java-008",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "hard",
    "experienceLevel": "senior",
    "field": "java",
    "category": "java",
    "question": "다음 중 Java에서 동시성 이슈를 해결하는 방법으로 옳지 않은 것은?",
    "options": [
      "synchronized 키워드 사용",
      "volatile 변수 선언",
      "ThreadLocal 사용",
      "Thread.sleep() 사용"
    ],
    "correctAnswer": 3,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 15,
    "tags": [
      "동시성",
      "멀티스레드"
    ]
  },
  {
    "id": "java-009",
    "type": "technical",
    "format": "essay",
    "difficulty": "medium",
    "experienceLevel": "senior",
    "field": "java",
    "category": "java",
    "question": "Spring Boot에서 자동 설정(Auto Configuration)의 원리를 설명하고, 필요한 경우 이를 어떻게 커스터마이징하는지 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "@Conditional 어노테이션 기반으로 Bean을 자동 구성하며, @Configuration과 @Bean으로 직접 재정의할 수 있습니다.",
    "requiredKeywords": [
      "@Conditional",
      "자동 설정",
      "커스터마이징"
    ],
    "points": 15,
    "tags": [
      "Spring Boot",
      "자동설정",
      "구성"
    ]
  },
  {
    "id": "java-010",
    "type": "technical",
    "format": "essay",
    "difficulty": "medium",
    "experienceLevel": "senior",
    "field": "java",
    "category": "java",
    "question": "JPA에서 트랜잭션 전파(Propagation)의 개념과 실무에서의 사용 시 고려사항을 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "트랜잭션 전파는 기존 트랜잭션에 참여할지 여부를 결정합니다. Propagation.REQUIRED, REQUIRES_NEW 등을 상황에 맞게 사용해야 합니다.",
    "requiredKeywords": [
      "Propagation",
      "REQUIRED",
      "REQUIRES_NEW"
    ],
    "points": 15,
    "tags": [
      "JPA",
      "트랜잭션",
      "전파"
    ]
  },
  {
    "id": "java-011",
    "type": "technical",
    "format": "essay",
    "difficulty": "hard",
    "experienceLevel": "senior",
    "field": "java",
    "category": "java",
    "question": "JVM 메모리 구조에 대해 설명하고, 메모리 부족(OutOfMemoryError)이 발생했을 때 실무적으로 어떻게 대응할 수 있는지 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "Heap, Stack, Metaspace 등으로 구성되며, 로그 분석과 힙 덤프, GC 튜닝 등을 통해 원인을 분석하고 해결합니다.",
    "requiredKeywords": [
      "Heap",
      "GC 튜닝",
      "OutOfMemoryError"
    ],
    "points": 20,
    "tags": [
      "JVM",
      "메모리관리",
      "실무"
    ]
  },
  {
    "id": "java-012",
    "type": "technical",
    "format": "essay",
    "difficulty": "hard",
    "experienceLevel": "senior",
    "field": "java",
    "category": "java",
    "question": "Spring 애플리케이션에서 동시성 이슈를 고려할 때, 멀티스레드 환경에서의 Bean 관리 및 동기화 전략을 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "싱글톤 Bean은 상태를 가지지 않도록 설계하거나 ThreadLocal, synchronized, ReentrantLock 등을 통해 동기화를 처리합니다.",
    "requiredKeywords": [
      "싱글톤",
      "ThreadLocal",
      "동기화"
    ],
    "points": 20,
    "tags": [
      "Spring",
      "동시성",
      "멀티스레드"
    ]
  },
  {
    "id": "mariadb-001",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "easy",
    "experienceLevel": "junior",
    "field": "java",
    "category": "mariadb",
    "question": "다음 중 SQL에서 데이터를 정렬할 때 사용하는 키워드는?",
    "options": [
      "GROUP BY",
      "ORDER BY",
      "SORT",
      "RANK BY"
    ],
    "correctAnswer": 1,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 5,
    "tags": [
      "SQL",
      "정렬",
      "기초"
    ]
  },
  {
    "id": "mariadb-002",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "medium",
    "experienceLevel": "junior",
    "field": "java",
    "category": "mariadb",
    "question": "INNER JOIN을 사용할 때의 조건으로 올바른 것은?",
    "options": [
      "두 테이블 모두 조건에 맞는 행이 있을 때만 결과에 포함된다",
      "한쪽 테이블만 조건을 만족하면 결과에 포함된다",
      "조건 없이 전체 결과를 반환한다",
      "두 테이블을 하나로 병합한다"
    ],
    "correctAnswer": 0,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 10,
    "tags": [
      "JOIN",
      "INNER JOIN",
      "관계"
    ]
  },
  {
    "id": "mariadb-003",
    "type": "technical",
    "format": "essay",
    "difficulty": "medium",
    "experienceLevel": "junior",
    "field": "java",
    "category": "mariadb",
    "question": "SQL에서 인덱스(Index)의 역할은 무엇이며, 어떤 컬럼에 적용하는 것이 효과적인지 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "인덱스는 검색 성능을 향상시키며, 주로 WHERE 조건에 자주 사용되거나 JOIN에 사용되는 컬럼에 적용합니다.",
    "requiredKeywords": [
      "검색 성능",
      "WHERE",
      "JOIN"
    ],
    "points": 15,
    "tags": [
      "인덱스",
      "성능"
    ]
  },
  {
    "id": "mariadb-004",
    "type": "technical",
    "format": "essay",
    "difficulty": "hard",
    "experienceLevel": "junior",
    "field": "java",
    "category": "mariadb",
    "question": "트랜잭션의 ACID 속성을 설명하고, 각각이 어떤 역할을 하는지 실무 예시를 들어 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "ACID는 원자성, 일관성, 고립성, 지속성을 의미하며, 예를 들어 은행 송금 시 전체 처리가 완료되어야 데이터 무결성이 유지됩니다.",
    "requiredKeywords": [
      "원자성",
      "일관성",
      "고립성",
      "지속성"
    ],
    "points": 20,
    "tags": [
      "트랜잭션",
      "ACID"
    ]
  },
  {
    "id": "mariadb-005",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "medium",
    "experienceLevel": "senior",
    "field": "java",
    "category": "mariadb",
    "question": "다음 중 인덱스가 무시될 수 있는 상황은?",
    "options": [
      "WHERE 절에 LIKE 'A%'가 있는 경우",
      "함수가 컬럼에 적용된 경우",
      "PRIMARY KEY에 조건을 건 경우",
      "ORDER BY 절만 있는 경우"
    ],
    "correctAnswer": 1,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 10,
    "tags": [
      "인덱스",
      "최적화"
    ]
  },
  {
    "id": "mariadb-006",
    "type": "technical",
    "format": "multiple-choice",
    "difficulty": "hard",
    "experienceLevel": "senior",
    "field": "java",
    "category": "mariadb",
    "question": "다음 중 격리 수준(isolation level)이 높은 순서대로 올바르게 나열한 것은?",
    "options": [
      "READ UNCOMMITTED < READ COMMITTED < REPEATABLE READ < SERIALIZABLE",
      "READ COMMITTED < READ UNCOMMITTED < REPEATABLE READ < SERIALIZABLE",
      "REPEATABLE READ < READ COMMITTED < READ UNCOMMITTED < SERIALIZABLE",
      "READ COMMITTED < REPEATABLE READ < READ UNCOMMITTED < SERIALIZABLE"
    ],
    "correctAnswer": 0,
    "correctAnswerText": "",
    "requiredKeywords": [],
    "points": 15,
    "tags": [
      "격리수준",
      "트랜잭션"
    ]
  },
  {
    "id": "mariadb-007",
    "type": "technical",
    "format": "essay",
    "difficulty": "hard",
    "experienceLevel": "senior",
    "field": "java",
    "category": "mariadb",
    "question": "복잡한 쿼리에서 성능을 최적화하기 위한 방법들을 실무 관점에서 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "인덱스 활용, EXPLAIN 분석, LIMIT 사용, 서브쿼리 대신 JOIN 활용 등이 있으며, 쿼리 실행 계획을 기반으로 튜닝합니다.",
    "requiredKeywords": [
      "EXPLAIN",
      "인덱스",
      "서브쿼리",
      "튜닝"
    ],
    "points": 20,
    "tags": [
      "성능최적화",
      "쿼리튜닝"
    ]
  },
  {
    "id": "mariadb-008",
    "type": "technical",
    "format": "essay",
    "difficulty": "hard",
    "experienceLevel": "senior",
    "field": "java",
    "category": "mariadb",
    "question": "대규모 테이블에서 데이터를 분산 저장하기 위한 파티셔닝(partitioning)의 개념과 적용 시 고려사항을 설명해주세요.",
    "options": [],
    "correctAnswer": "",
    "correctAnswerText": "파티셔닝은 테이블을 논리적으로 분할하여 성능을 높이는 기술이며, 파티션 키 설계와 쿼리 범위 조건 등이 중요합니다.",
    "requiredKeywords": [
      "파티셔닝",
      "성능",
      "파티션 키"
    ],
    "points": 20,
    "tags": [
      "파티셔닝",
      "대용량",
      "성능"
    ]
  }
]